-- ResearchMonad.hs
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeFamilies #-}

module ResearchMonad (
    Research,
    Hypothesis(..),
    Discovery(..),
    DataContract(..),
    StatisticalTestSpec(..),
    Scaffold(..),
    ResearchError(..),
    testHypothesis,
    runResearch,
    logMessage
) where

import Control.Monad.State
import Control.Monad.Except (ExceptT, runExceptT, throwError, liftEither)
import Control.Monad (when)
import Protocol (StatisticalProtocol(..), ProtocolError(..))
import Text.Printf (printf)
import System.Directory (createDirectoryIfMissing)
import System.FilePath ((</>))

-- ============================================================================
-- Declarative Scaffolding Definitions
-- ============================================================================

data DataContract = DataContract {
    explorationDataPath :: FilePath,
    validationDataPath :: FilePath
} deriving (Show, Eq)

data StatisticalTestSpec = PairedTTest { repetitions :: Int, folds :: Int }
                         | WilcoxonSignedRank
                         | SimulationOnly
                         deriving (Show, Eq)

data Scaffold = Scaffold {
    scaffoldPath :: FilePath,
    contract :: DataContract,
    testSpec :: StatisticalTestSpec,
    executeHarness :: IO (Maybe Double)
}

instance Show Scaffold where
    show s = printf "Scaffold {path = %s, test = %s}" (scaffoldPath s) (show $ testSpec s)

-- ============================================================================
-- Core Monad Definitions
-- ============================================================================

data ResearchError = RProtocolError ProtocolError
                   | RScaffoldError String
                   | RExecutionError String
                   deriving (Show, Eq)

-- | A Hypothesis generated by the AI-Scientist.
data Hypothesis = Hypothesis {
    hId :: Int,
    description :: String,
    hContract :: DataContract,
    hTestSpec :: StatisticalTestSpec,
    -- Scaffold generation now returns Either ResearchError Scaffold
    generateScaffold :: FilePath -> Hypothesis -> IO (Either ResearchError Scaffold)
}

instance Show Hypothesis where
    show h = printf "Hypothesis {hId = %d, description = \"%s\", test = %s}"
                    (hId h) (description h) (show $ hTestSpec h)

data Discovery = Discovery {
    dHypothesis :: Hypothesis,
    dPValue :: Double,
    dAlphaT :: Double
} deriving (Show)

-- | The Generalized Research Monad definition.
--   Now includes ExceptT for robust error handling over StateT.
type Research s m a = ExceptT ResearchError (StateT s m) a

-- ============================================================================
-- Core Operations
-- ============================================================================

-- | The core operation of the eDSL: Testing a hypothesis.
testHypothesis :: (MonadIO m, StatisticalProtocol s) => FilePath -> Hypothesis -> Bool -> Research s m (Maybe Discovery)
testHypothesis workspaceDir hypothesis verbose = do
    -- 1. Retrieve the current protocol state (using 'lift' to access StateT).
    currentState <- lift get
    
    -- 2. Declarative Enforcement: Generate the Scaffold.
    when verbose $ logMessage $ printf "H%d: Generating Scaffold..." (hId hypothesis)
    scaffoldResult <- liftIO $ (generateScaffold hypothesis) workspaceDir hypothesis
    scaffold <- liftEither scaffoldResult
    
    -- 3. LLM Generation (Simulated Step).
    when verbose $ logMessage $ printf "H%d: Generating Implementation (LLM)..." (hId hypothesis)
    liftIO $ simulateLLMImplementation scaffold

    -- 4. Execution: Run the P-Value Bridge within the safeguarded environment.
    when verbose $ logMessage $ printf "H%d: Executing Harness..." (hId hypothesis)
    p_value_maybe <- liftIO $ executeHarness scaffold
    
    case p_value_maybe of
        Nothing -> do
            when verbose $ logMessage $ printf "H%d: Execution failed or exploration yielded no artifact." (hId hypothesis)
            -- We do not throwError here, as execution failure is a valid outcome of a test.
            return Nothing
            
        Just p_value -> do
            -- 5. Monadic Accounting: Advance the state using the protocol logic.
            let (isDiscovery, alpha_t, newState) = advanceState p_value currentState
            
            -- 6. Validate the transition and update the state.
            case isValidTransition currentState newState of
                -- Use 'throwError' to halt execution robustly within ExceptT.
                Left protocolErr -> throwError $ RProtocolError protocolErr
                Right () -> lift $ put newState
            
            -- 7. Log the outcome
            when verbose $ do
                let msg = printf "Tested H%d: P=%.5f, Alpha_t=%.5f, Discovery=%s" 
                                 (hId hypothesis) p_value alpha_t (show isDiscovery)
                logMessage msg

            -- 8. Return the result.
            if isDiscovery
            then return $ Just (Discovery hypothesis p_value alpha_t)
            else return Nothing

-- | Runner function to execute the Research computation.
runResearch :: (Monad m, StatisticalProtocol s) => Config s -> Research s m a -> m (Either ResearchError a, Maybe s)
runResearch config program = do
    case initializeState config of
        Left initError -> return (Left $ RProtocolError initError, Nothing)
        Right initialState -> do
            (result, finalState) <- runStateT (runExceptT program) initialState
            return (result, Just finalState)

-- | Helper function for logging.
logMessage :: MonadIO m => String -> Research s m ()
logMessage msg = liftIO $ putStrLn msg

-- ============================================================================
-- Simulated Scaffolding Implementation
-- ============================================================================

-- | Simulates the generation of the Python harness.
generatePythonHarness :: Scaffold -> IO ()
generatePythonHarness scaffold = do
    let path = scaffoldPath scaffold
    createDirectoryIfMissing True path
    
    let harnessCode = unlines [
            "# harness.py (Generated by Haskell Orchestrator)",
            "import implementation",
            "import pandas as pd",
            "from verified_stats import execute_paired_ttest # Conceptual pre-verified library",
            "",
            printf "EXPLORATION_DATA = pd.read_csv(\"%s\")" (explorationDataPath $ contract scaffold),
            printf "VALIDATION_DATA = pd.read_csv(\"%s\")" (validationDataPath $ contract scaffold),
            "",
            "def run_exploration():",
            "    artifact = implementation.optimize(EXPLORATION_DATA)",
            "    return artifact",
            "",
            "def run_validation(artifact, baseline):",
            "    # ... evaluation logic ...",
            "    # p_value = execute_paired_ttest(scores_A, scores_B)",
            "    return 0.01 # Placeholder"
            ]
    writeFile (path </> "harness.py") harnessCode

-- | Simulates the LLM generating the implementation file.
simulateLLMImplementation :: Scaffold -> IO ()
simulateLLMImplementation scaffold = do
    let path = scaffoldPath scaffold
    let implementationCode = unlines [
            "# implementation.py (Generated by LLM Coder Agent)",
            "def optimize(data):",
            "    return {'model': 'OptimizedModel'}",
            "def evaluate_model(artifact, data):",
            "    return [0.9, 0.8, 0.95]"
            ]
    case testSpec scaffold of
        SimulationOnly -> return ()
        _ -> do
            generatePythonHarness scaffold
            writeFile (path </> "implementation.py") implementationCode
